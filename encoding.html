<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Encoding - Rust Cookbook</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Collection of useful Rust code examples">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        
        <link rel="stylesheet" href="theme/custom.css">
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

        <!-- Custom JS script -->
        

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="intro.html">Table of Contents</a></li><li class="affix"><a href="about.html">About</a></li><li><a href="basics.html"><strong>1.</strong> Basics</a></li><li><a href="encoding.html" class="active"><strong>2.</strong> Encoding</a></li><li><a href="concurrency.html"><strong>3.</strong> Concurrency</a></li><li><a href="net.html"><strong>4.</strong> Networking</a></li><li><a href="app.html"><strong>5.</strong> Application development</a></li><li><a href="logging.html"><strong>6.</strong> Logging</a></li><li><a href="build_tools.html"><strong>7.</strong> Build Time Tooling</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <!-- START - Rust Cookbook customization -->
                        <i id="edit-button" class="fa fa-edit">Edit</i>
                        <!-- END - Rust Cookbook customization -->
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">Rust Cookbook</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="encoding.html#encoding" id="encoding"><h1>Encoding</h1></a>
<table><thead><tr><th> Recipe </th><th> Crates </th><th> Categories </th></tr></thead><tbody>
<tr><td> <a href="encoding.html#ex-json-value">Serialize and deserialize unstructured JSON</a> </td><td> <a href="https://docs.serde.rs/serde_json/"><img src="https://badge-cache.kominick.com/crates/v/serde_json.svg?label=serde_json" alt="serde-json-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="encoding.html#ex-toml-config">Deserialize a TOML configuration file</a> </td><td> <a href="https://docs.rs/toml/"><img src="https://badge-cache.kominick.com/crates/v/toml.svg?label=toml" alt="toml-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="encoding.html#ex-percent-encode">Percent-encode a string</a> </td><td> <a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="encoding.html#ex-urlencoded">Encode a string as application/x-www-form-urlencoded</a> </td><td> <a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="encoding.html#ex-hex-encode-decode">Encode and decode hex</a> </td><td> <a href="https://docs.rs/data-encoding/"><img src="https://badge-cache.kominick.com/crates/v/data-encoding.svg?label=data-encoding" alt="data-encoding-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="encoding.html#ex-base64">Encode and decode base64</a> </td><td> <a href="https://docs.rs/base64/"><img src="https://badge-cache.kominick.com/crates/v/base64.svg?label=base64" alt="base64-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="encoding.html#ex-serialize-csv">Serialize records to CSV</a> </td><td> <a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="encoding.html#ex-csv-serde">Serialize records to CSV using Serde</a> </td><td> <a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="encoding.html#ex-invalid-csv">Handle invalid CSV data with Serde</a> </td><td> <a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="encoding.html#ex-csv-delimiter">Read CSV records with different delimeter</a> </td><td> <a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="encoding.html#ex-csv-filter">Filter CSV records matching a predicate</a> </td><td> <a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a> </td></tr>
</tbody></table>
<p><a name="ex-json-value"></a></p>
<a class="header" href="encoding.html#serialize-and-deserialize-unstructured-json" id="serialize-and-deserialize-unstructured-json"><h2>Serialize and deserialize unstructured JSON</h2></a>
<p><a href="https://docs.serde.rs/serde_json/"><img src="https://badge-cache.kominick.com/crates/v/serde_json.svg?label=serde_json" alt="serde-json-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>The <a href="https://docs.serde.rs/serde_json/"><code>serde_json</code></a> crate provides a <a href="https://docs.serde.rs/serde_json/fn.from_str.html"><code>from_str</code></a> function to parse a <code>&amp;str</code> of
JSON into a type of the caller's choice.</p>
<p>Unstructured JSON can be parsed into a universal <a href="https://docs.serde.rs/serde_json/enum.Value.html"><code>serde_json::Value</code></a> type that
is able to represent any valid JSON data.</p>
<p>The example below shows a <code>&amp;str</code> of JSON being parsed and then compared to what
we expect the parsed value to be. The expected value is declared using the
<a href="https://docs.serde.rs/serde_json/macro.json.html"><code>json!</code></a> macro.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
#[macro_use]
extern crate serde_json;

use serde_json::Value;
#
# error_chain! {
#     foreign_links {
#         Json(serde_json::Error);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let j = r#&quot;{
                 &quot;userid&quot;: 103609,
                 &quot;verified&quot;: true,
                 &quot;access_privileges&quot;: [
                   &quot;user&quot;,
                   &quot;admin&quot;
                 ]
               }&quot;#;

    let parsed: Value = serde_json::from_str(j)?;

    let expected = json!({
        &quot;userid&quot;: 103609,
        &quot;verified&quot;: true,
        &quot;access_privileges&quot;: [
            &quot;user&quot;,
            &quot;admin&quot;
        ]
    });

    assert_eq!(parsed, expected);

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-toml-config"></a></p>
<a class="header" href="encoding.html#deserialize-a-toml-configuration-file" id="deserialize-a-toml-configuration-file"><h2>Deserialize a TOML configuration file</h2></a>
<p><a href="https://docs.rs/toml/"><img src="https://badge-cache.kominick.com/crates/v/toml.svg?label=toml" alt="toml-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>Parse some TOML into a universal <code>toml::Value</code> that is able to represent any
valid TOML data.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate toml;

use toml::Value;
#
# error_chain! {
#     foreign_links {
#         Toml(toml::de::Error);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let toml_content = r#&quot;
          [package]
          name = &quot;your_package&quot;
          version = &quot;0.1.0&quot;
          authors = [&quot;You! &lt;you@example.org&gt;&quot;]

          [dependencies]
          serde = &quot;1.0&quot;
          &quot;#;

    let package_info: Value = toml::from_str(toml_content)?;

    assert_eq!(package_info[&quot;dependencies&quot;][&quot;serde&quot;].as_str(), Some(&quot;1.0&quot;));
    assert_eq!(package_info[&quot;package&quot;][&quot;name&quot;].as_str(),
               Some(&quot;your_package&quot;));

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p>Parse TOML into your own structs using Serde:</p>
<p><a href="https://docs.serde.rs/serde_json/"><img src="https://badge-cache.kominick.com/crates/v/serde_json.svg?label=serde_json" alt="serde-json-badge" /></a> <a href="https://docs.rs/toml/"><img src="https://badge-cache.kominick.com/crates/v/toml.svg?label=toml" alt="toml-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
#[macro_use]
extern crate serde_derive;
extern crate toml;

use std::collections::HashMap;

#[derive(Deserialize)]
struct Config {
    package: Package,
    dependencies: HashMap&lt;String, String&gt;,
}

#[derive(Deserialize)]
struct Package {
    name: String,
    version: String,
    authors: Vec&lt;String&gt;,
}
#
# error_chain! {
#     foreign_links {
#         Toml(toml::de::Error);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let toml_content = r#&quot;
          [package]
          name = &quot;your_package&quot;
          version = &quot;0.1.0&quot;
          authors = [&quot;You! &lt;you@example.org&gt;&quot;]

          [dependencies]
          serde = &quot;1.0&quot;
          &quot;#;

    let package_info: Config = toml::from_str(toml_content)?;

    assert_eq!(package_info.package.name, &quot;your_package&quot;);
    assert_eq!(package_info.package.version, &quot;0.1.0&quot;);
    assert_eq!(package_info.package.authors, vec![&quot;You! &lt;you@example.org&gt;&quot;]);
    assert_eq!(package_info.dependencies[&quot;serde&quot;], &quot;1.0&quot;);

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-percent-encode"></a></p>
<a class="header" href="encoding.html#percent-encode-a-string" id="percent-encode-a-string"><h2>Percent-encode a string</h2></a>
<p><a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>Encode an input string with <a href="https://en.wikipedia.org/wiki/Percent-encoding">percent-encoding</a> using the <a href="https://docs.rs/url/1.*/url/percent_encoding/fn.utf8_percent_encode.html"><code>utf8_percent_encode</code></a>
function from the <code>url</code> crate. Then decode using the <a href="https://docs.rs/url/1.*/url/percent_encoding/fn.percent_decode.html"><code>percent_decode</code></a>
function.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate url;

use url::percent_encoding::{utf8_percent_encode, percent_decode, DEFAULT_ENCODE_SET};
#
# error_chain! {
#     foreign_links {
#         Utf8(std::str::Utf8Error);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let input = &quot;confident, productive systems programming&quot;;

    let iter = utf8_percent_encode(input, DEFAULT_ENCODE_SET);
    let encoded: String = iter.collect();
    assert_eq!(encoded, &quot;confident,%20productive%20systems%20programming&quot;);

    let iter = percent_decode(encoded.as_bytes());
    let decoded = iter.decode_utf8()?;
    assert_eq!(decoded, &quot;confident, productive systems programming&quot;);

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p>The encode set defines which bytes (in addition to non-ASCII and controls) need
to be percent-encoded. The choice of this set depends on context. For example,
<code>?</code> needs to be encoded in a URL path but not in a query string.</p>
<p>The return value of encoding is an iterator of <code>&amp;str</code> slices which can be
collected into a <code>String</code>.</p>
<p><a name="ex-urlencoded"></a></p>
<a class="header" href="encoding.html#encode-a-string-as-applicationx-www-form-urlencoded" id="encode-a-string-as-applicationx-www-form-urlencoded"><h2>Encode a string as application/x-www-form-urlencoded</h2></a>
<p><a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>Encodes a string into <a href="https://url.spec.whatwg.org/#application/x-www-form-urlencoded">application/x-www-form-urlencoded</a> syntax
using the <a href="https://docs.rs/url/1.4.0/url/form_urlencoded/fn.byte_serialize.html"><code>form_urlencoded::byte_serialize</code></a> and subsequently
decodes it with <a href="https://docs.rs/url/*/url/form_urlencoded/fn.parse.html"><code>form_urlencoded::parse</code></a>. Both functions return iterators
that can be collected into a <code>String</code>.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate url;
use url::form_urlencoded::{byte_serialize, parse};

fn main() {
    let urlencoded: String = byte_serialize(&quot;What is ❤?&quot;.as_bytes()).collect();
    assert_eq!(urlencoded, &quot;What+is+%E2%9D%A4%3F&quot;);
    println!(&quot;urlencoded:'{}'&quot;, urlencoded);

    let decoded: String = parse(urlencoded.as_bytes())
        .map(|(key, val)| [key, val].concat())
        .collect();
    assert_eq!(decoded, &quot;What is ❤?&quot;);
    println!(&quot;decoded:'{}'&quot;, decoded);
}
</code></pre></pre>
<p><a name="ex-hex-encode-decode"></a></p>
<a class="header" href="encoding.html#encode-and-decode-hex" id="encode-and-decode-hex"><h2>Encode and decode hex</h2></a>
<p><a href="https://docs.rs/data-encoding/"><img src="https://badge-cache.kominick.com/crates/v/data-encoding.svg?label=data-encoding" alt="data-encoding-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>The <a href="https://github.com/ia0/data-encoding"><code>data_encoding</code></a> crate provides a <code>HEXUPPER::encode</code> method which
takes a <code>&amp;[u8]</code> and returns a <code>String</code> containing the hexadecimal
representation of the data.</p>
<p>Similarly, a <code>HEXUPPER::decode</code> method is provided which takes a <code>&amp;[u8]</code> and
returns a <code>Vec&lt;u8&gt;</code> if the input data is successfully decoded.</p>
<p>The example below shows a <code>&amp;[u8]</code> of data being converted to its hexadecimal
representation and then being compared to its expected value. The returned
hex <code>String</code> is then converted back to its original representation and is
compared to the original value provided.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate data_encoding;

use data_encoding::{HEXUPPER, DecodeError};
#
# error_chain! {
#     foreign_links {
#         Decode(DecodeError);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let original = b&quot;The quick brown fox jumps over the lazy dog.&quot;;
    let expected = &quot;54686520717569636B2062726F776E20666F78206A756D7073206F76\
        657220746865206C617A7920646F672E&quot;;

    let encoded = HEXUPPER.encode(original);
    assert_eq!(encoded, expected);

    let decoded = HEXUPPER.decode(&amp;encoded.into_bytes())?;
    assert_eq!(&amp;decoded[..], &amp;original[..]);

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-base64"></a></p>
<a class="header" href="encoding.html#encode-and-decode-base64" id="encode-and-decode-base64"><h2>Encode and decode base64</h2></a>
<p><a href="https://docs.rs/base64/"><img src="https://badge-cache.kominick.com/crates/v/base64.svg?label=base64" alt="base64-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>Encodes byte slice into <code>base64</code> String with help of <a href="https://docs.rs/base64/*/base64/fn.encode.html"><code>encode</code></a>
and subsequently decodes it with <a href="https://docs.rs/base64/*/base64/fn.decode.html"><code>decode</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate base64;

use std::str;
use base64::{encode, decode};
#
# error_chain! {
#     foreign_links {
#         Base64(base64::DecodeError);
#         Utf8Error(str::Utf8Error);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let hello = b&quot;hello rustaceans&quot;;
    let encoded = encode(hello);
    let decoded = decode(&amp;encoded)?;

    println!(&quot;origin: {}&quot;, str::from_utf8(hello)?);
    println!(&quot;base64 encoded: {}&quot;, encoded);
    println!(&quot;back to origin: {}&quot;, str::from_utf8(&amp;decoded)?);

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-serialize-csv"></a></p>
<a class="header" href="encoding.html#serialize-records-to-csv" id="serialize-records-to-csv"><h2>Serialize records to CSV</h2></a>
<p><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>This example shows how to serialize a Rust tuple. <a href="https://docs.rs/csv/*/csv/struct.Writer.html"><code>csv::writer</code></a> supports automatic
serialization from Rust types into CSV records. <a href="https://docs.rs/csv/*/csv/struct.Writer.html#method.write_record"><code>write_record</code></a> is used when writing
a simple record that contains string-like data only, <a href="https://docs.rs/csv/*/csv/struct.Writer.html#method.serialize"><code>serialize</code></a> is used when data
consists of more complex values like numbers, floats or optional values. Since CSV
writer uses internal buffer, always explicitly <a href="https://docs.rs/csv/*/csv/struct.Writer.html#method.flush"><code>flush</code></a> when done.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate csv;

use std::io;
#
# error_chain! {
#     foreign_links {
#         CSVError(csv::Error);
#         IOError(std::io::Error);
#    }
# }

fn run() -&gt; Result&lt;()&gt; {
    let mut wtr = csv::Writer::from_writer(io::stdout());

    wtr.write_record(&amp;[&quot;Name&quot;, &quot;Place&quot;, &quot;ID&quot;])?;

    wtr.serialize((&quot;Mark&quot;, &quot;Sydney&quot;, 87))?;
    wtr.serialize((&quot;Ashley&quot;, &quot;Dublin&quot;, 32))?;
    wtr.serialize((&quot;Akshat&quot;, &quot;Delhi&quot;, 11))?;

    wtr.flush()?;
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-csv-serde"></a></p>
<a class="header" href="encoding.html#serialize-records-to-csv-using-serde" id="serialize-records-to-csv-using-serde"><h2>Serialize records to CSV using Serde</h2></a>
<p><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>The following example shows how to serialize custom structs as CSV records using
the <a href="https://docs.rs/serde/">serde</a> crate.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate csv;
#[macro_use]
extern crate serde_derive;

use std::io;
#
# error_chain! {
#    foreign_links {
#        IOError(std::io::Error);
#        CSVError(csv::Error);
#    }
# }

#[derive(Debug, Serialize)]
struct Record&lt;'a&gt; {
    name: &amp;'a str,
    place: &amp;'a str,
    id: u64,
}

fn run() -&gt; Result&lt;()&gt; {
    let mut wtr = csv::Writer::from_writer(io::stdout());

    let rec1 = Record { name: &quot;Mark&quot;, place: &quot;Melbourne&quot;, id: 56};
    let rec2 = Record { name: &quot;Ashley&quot;, place: &quot;Sydney&quot;, id: 64};
    let rec3 = Record { name: &quot;Akshat&quot;, place: &quot;Delhi&quot;, id: 98};

    wtr.serialize(rec1)?;
    wtr.serialize(rec2)?;
    wtr.serialize(rec3)?;

    wtr.flush()?;

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-invalid-csv"></a></p>
<a class="header" href="encoding.html#handle-invalid-csv-data-with-serde" id="handle-invalid-csv-data-with-serde"><h2>Handle invalid CSV data with Serde</h2></a>
<p><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>CSV files often contain invalid data. For these cases, the csv crate
provides a custom deserializer, <a href="https://docs.rs/csv/*/csv/fn.invalid_option.html"><code>csv::invalid_option</code></a>, which automatically
converts invalid data to None values.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate csv;
#[macro_use]
extern crate serde_derive;

#[derive(Debug, Deserialize)]
struct Record {
    name: String,
    place: String,
    #[serde(deserialize_with = &quot;csv::invalid_option&quot;)]
    id: Option&lt;u64&gt;,
}
#
# error_chain! {
#     foreign_links {
#         CsvError(csv::Error);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let data = &quot;name,place,id
mark,sydney,46.5
ashley,zurich,92
akshat,delhi,37
alisha,colombo,xyz&quot;;

    let mut rdr = csv::Reader::from_reader(data.as_bytes());
    for result in rdr.deserialize() {
        let record: Record = result?;
        println!(&quot;{:?}&quot;, record);
    }

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-csv-delimiter"></a></p>
<a class="header" href="encoding.html#read-csv-records-with-different-delimeter" id="read-csv-records-with-different-delimeter"><h2>Read CSV records with different delimeter</h2></a>
<p><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>Reads CSV records with <a href="https://docs.rs/csv/1.0.0-beta.3/csv/struct.ReaderBuilder.html#method.delimiter"><code>delimiter</code></a> other than ','</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate csv;
#[macro_use]
extern crate serde_derive;

#[derive(Debug, Deserialize)]
struct Record {
    name: String,
    place: String,
    #[serde(deserialize_with = &quot;csv::invalid_option&quot;)]
    id: Option&lt;u64&gt;,
}

use csv::ReaderBuilder;
#
# error_chain! {
#     foreign_links {
#         CsvError(csv::Error);
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let data = &quot;name-place-id
Mark-Melbourne-46
Ashley-Zurich-92&quot;;

    let mut reader = ReaderBuilder::new().delimiter(b'-').from_reader(data.as_bytes());
    for result in reader.records() {
        println!(&quot;{:?}&quot;, result?);
    }

    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><a name="ex-csv-filter"></a></p>
<a class="header" href="encoding.html#filter-csv-records-matching-a-predicate" id="filter-csv-records-matching-a-predicate"><h2>Filter CSV records matching a predicate</h2></a>
<p><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>Returns <em>only</em> the rows from <code>data</code> with a field that matches <code>query</code>.</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use]
# extern crate error_chain;
extern crate csv;

use std::io;
#
# error_chain!{
#     foreign_links {
#         Io(std::io::Error);
#         CsvError(csv::Error); // or just Seek(csv::Error)
#     }
# }

fn run() -&gt; Result&lt;()&gt; {
    let query = &quot;CA&quot;;
    let data = &quot;\
City,State,Population,Latitude,Longitude
Kenai,AK,7610,60.5544444,-151.2583333
Oakman,AL,,33.7133333,-87.3886111
Sandfort,AL,,32.3380556,-85.2233333
West Hollywood,CA,37031,34.0900000,-118.3608333&quot;;

    let mut rdr = csv::ReaderBuilder::new().from_reader(data.as_bytes());
    let mut wtr = csv::Writer::from_writer(io::stdout());

    wtr.write_record(rdr.headers()?)?;

    for result in rdr.records() {
        let record = result?;
        if record.iter().any(|field| field == query) {
            wtr.write_record(&amp;record)?;
        }
    }

    wtr.flush()?;
    Ok(())
}
#
# quick_main!(run);
</code></pre></pre>
<p><em>Disclaimer: this example has been adapted from <a href="https://docs.rs/csv/*/csv/tutorial/index.html#filter-by-search">the csv crate tutorial</a></em>.</p>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<!-- API Reference -->
<!-- Other Reference -->

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a rel="prev" href="basics.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="concurrency.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="basics.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="concurrency.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }

            // START - Rust Cookbook customization
            $("#edit-button").click(function(){
                var editWindow = window.open("https://github.com/rust-lang-nursery/rust-cookbook/edit/master/src/encoding.md");
            });
            // END - Rust Cookbook customization
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
